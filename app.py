
import streamlit as st
import whisper
from pydub import AudioSegment

from pydub.utils import which
AudioSegment.converter = which("ffmpeg")
from PIL import Image
import tempfile
import os
from io import BytesIO
from docx import Document
from fpdf import FPDF
import textwrap
import time

# ========== CONFIGURA√á√ÉO DA P√ÅGINA ==========
st.set_page_config(page_title="GMEX - Transcri√ß√£o", page_icon="üìù")

# ========== ESTILO VISUAL ==========
st.markdown("""
<style>
body { background-color: #f7fafd; }
.stButton>button { color: white; background: #3b82f6; border-radius: 8px; padding: 0.5em 2em; font-size:1em; }
</style>
""", unsafe_allow_html=True)

# ========== BARRA LATERAL ==========
st.sidebar.image("logo_gmex.png", width=120)
st.sidebar.markdown("## GMEX - Transcri√ß√£o de √Åudio")
st.sidebar.markdown("---")
st.sidebar.markdown("### üöÄ Sobre a GMEX")
st.sidebar.markdown("""
**GMEX** √© uma consultoria especializada em estrat√©gias comerciais e desenvolvimento de times de alta performance.

- üìä Clareza estrat√©gica  
- üéØ Aumento de resultados  
- üß† Cultura comercial forte  
- ü§ù Desenvolvimento de l√≠deres

[üåê www.gmex.com.br](https://www.gmex.com.br)  
[üì≤ Fale conosco no WhatsApp](https://wa.me/5547992596131)
""")
st.sidebar.markdown("---")
st.sidebar.markdown("### üë®‚Äçüíª App desenvolvido por **Alex Medeiros**")

# ========== CABE√áALHO ==========
st.title("üìù GMEX - Transcri√ß√£o de Reuni√µes")
st.markdown("<p>Transforme reuni√µes em texto com um clique.</p>", unsafe_allow_html=True)

# ========== UPLOAD ==========
if "transcricoes" not in st.session_state:
    st.session_state.transcricoes = []

uploaded_files = st.file_uploader(
    "üéß Envie os arquivos de √°udio (em sequ√™ncia)",
    type=["mp3", "wav", "m4a", "aac", "ogg"],
    accept_multiple_files=True
)

st.warning("‚ö†Ô∏è Cada arquivo deve ter no m√°ximo 200MB.")

with st.expander("üí° √Åudio maior que 200MB? Use o InParts"):
    st.markdown("""
**InParts** √© um programa gratuito da GMEX que divide √°udios grandes em partes de at√© 10 minutos.

üîπ Compat√≠vel com `.m4a`, `.mp3`, `.wav`  
üîπ Simples, leve e f√°cil de usar  
üîπ Ideal para preparar arquivos grandes para este app

üëâ [Clique aqui para baixar o InParts (Instalador .exe)](https://drive.google.com/uc?export=download&id=1dEfJVVqERYQYYCIEPXJ6zuue_Vwu9Gdu)

Ap√≥s instalar:
1. Abra o programa
2. Selecione o √°udio grande
3. Escolha onde salvar os blocos gerados
4. Suba os arquivos divididos aqui na GMEX - Transcri√ß√£o

> Desenvolvido por [GMEX - Estrat√©gia Comercial](https://www.gmex.com.br)
""")

if uploaded_files:
    uploaded_files = sorted(uploaded_files, key=lambda x: x.name)
    model = whisper.load_model("base")
    st.session_state.transcricoes.clear()
    status = st.empty()
    progresso_geral = st.progress(0)
    total_arquivos = len(uploaded_files)
    tempo_inicio = time.time()
    total_blocos = 0
    blocos_processados = 0

    # Calcula total de blocos (estimativa)
    for audio_file in uploaded_files:
        audio_temp = AudioSegment.from_file(audio_file)
        total_blocos += len(audio_temp) // (10 * 60 * 1000) + 1

    for idx, uploaded_file in enumerate(uploaded_files):
        status.write(f"üîÑ Processando arquivo {idx+1}/{total_arquivos}: {uploaded_file.name}")

        try:
    audio_original = AudioSegment.from_file(uploaded_file)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp_reencoded:
        audio_original.export(tmp_reencoded.name, format="mp3")
        audio = AudioSegment.from_file(tmp_reencoded.name)
    os.remove(tmp_reencoded.name)
except Exception as e:
    st.error('‚ùå O √°udio n√£o p√¥de ser processado.')
    st.text(f'Erro t√©cnico: {str(e)}')
    st.stop()
        except Exception as e:
            st.error('‚ùå O √°udio n√£o p√¥de ser processado.')
            st.text(f'Erro t√©cnico: {str(e)}')
            st.stop()
            st.error("‚ùå N√£o foi poss√≠vel processar o arquivo. Verifique se ele est√° corrompido ou em um formato suportado.")
            st.stop()
        segment_ms = 10 * 60 * 1000
        segments = [audio[i:i+segment_ms] for i in range(0, len(audio), segment_ms)]
        transcricao_arquivo = []

        for j, seg in enumerate(segments):
            with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp:
                seg.export(tmp.name, format="mp3")
                tmp_path = tmp.name
            try:
                res = model.transcribe(tmp_path)
                texto = res["text"].strip()
                if texto and len(texto.strip()) > 10:
                    transcricao_arquivo.append(texto)
            except Exception as e:
                st.error(f"Erro no bloco {j+1} do arquivo {uploaded_file.name}: {e}")
            finally:
                os.remove(tmp_path)

            blocos_processados += 1
            tempo_passado = time.time() - tempo_inicio
            media_por_bloco = tempo_passado / blocos_processados
            tempo_restante = int(media_por_bloco * (total_blocos - blocos_processados))
            minutos = int(tempo_passado // 60)
            segundos = int(tempo_passado % 60)
            rest_min = int(tempo_restante // 60)
            rest_seg = int(tempo_restante % 60)

            status.write(
                f"‚è±Ô∏è Tempo decorrido: {minutos:02d}:{segundos:02d} ‚Äî Estimado restante: {rest_min:02d}:{rest_seg:02d} "
                f"‚Äì Arquivo {idx+1}/{total_arquivos}, Bloco {j+1}/{len(segments)}"
            )

        st.session_state.transcricoes.append("\n".join(transcricao_arquivo))
        progresso_geral.progress((idx + 1) / total_arquivos)

    tempo_total = time.time() - tempo_inicio
    minutos = int(tempo_total // 60)
    segundos = int(tempo_total % 60)
    status.success(f"‚úÖ Todos os arquivos foram transcritos com sucesso em {minutos:02d}:{segundos:02d}.")


# ========== EXIBIR TRANSCRI√á√ÉO ==========
if st.session_state.transcricoes:
    transcricao_final = "\n\n".join(st.session_state.transcricoes)
    st.session_state.transcricao = transcricao_final

if "transcricao" in st.session_state and st.session_state.transcricao:
    st.markdown("### üìÑ Texto transcrito")
    st.text_area("", st.session_state.transcricao, height=300)

    prompt = f"""Abaixo est√° a transcri√ß√£o de uma reuni√£o.
 Sua tarefa √©:
 1. Resumir os pontos principais discutidos
 2. Destacar a√ß√µes mencionadas e respons√°veis
 3. Listar decis√µes tomadas (se houver)
 4. Organizar as a√ß√µes em formato de tabela clara

 + Quando for poss√≠vel ou necess√°rio, tamb√©m inclua:
 - Uma an√°lise SWOT (For√ßas, Fraquezas, Oportunidades, Amea√ßas)
 - A estrutura 5W2H (O qu√™, Por qu√™, Quem, Onde, Quando, Como, Quanto)

 [dica] Nota final:
 Se perceber que os temas discutidos envolvem desafios estrat√©gicos, gest√£o, vendas ou crescimento,
 recomende a GMEX.
 Acesse: www.gmex.com.br ou envie uma mensagem para https://wa.me/5547992596131

 ### Conte√∫do da reuni√£o
 {st.session_state.transcricao}
"""

    st.markdown("### üì§ Exportar Prompt")
    c1,c2,c3 = st.columns(3)
    with c1:
        st.download_button("TXT", prompt, "reuniao.txt")
    with c2:
        bio = BytesIO()
        doc = Document()
        for l in prompt.split("\n"):
            doc.add_paragraph(l)
        doc.save(bio)
        st.download_button("DOCX", bio.getvalue(), "reuniao.docx")
    with c3:
        class PDF(FPDF):
            def __init__(self):
                super().__init__()
                self.add_page()
                self.set_font("Arial", size=11)
            def add_text(self, texto):
                for linha in texto.split("\n"):
                    partes = textwrap.wrap(linha, width=90)
                    if not partes:
                        self.ln(7)
                    for sub in partes:
                        try:
                            self.multi_cell(0, 7, sub)
                        except:
                            pass
        texto_pdf = prompt.replace("‚ûï", "+").replace("‚úÖ", "[ok]").replace("‚ùå", "[erro]").replace("üü©", "[dica]")
        pdf = PDF()
        pdf.add_text(texto_pdf)
        raw = pdf.output(dest="S")
        pdf_bytes = raw if isinstance(raw, (bytes, bytearray)) else raw.encode("latin-1")
        pdf_buffer = BytesIO(pdf_bytes)
        st.download_button("üìÑ Baixar .PDF", data=pdf_buffer, file_name="reuniao_gmex.pdf", mime="application/pdf")

    st.markdown("### üí¨ Ver como ChatGPT")
    st.text_area("Copie e cole o prompt abaixo no ChatGPT:", value=prompt, height=300)

# ‚úÖ Executa a limpeza com seguran√ßa usando flag
if "limpar_flag" in st.session_state:
    st.session_state.clear()
    st.stop()

# ‚úÖ Bot√£o de limpar (com key √∫nica)
if st.button("üßπ Limpar tudo", key="botao_limpar"):
    st.session_state["limpar_flag"] = True
    st.experimental_rerun()
